// Code generated by 'go generate'; EDIT AT YOUR OWN RISK.

package executeassembly

import (
	"syscall"
	"unsafe"

	"github.com/atsika/myproc"
	"golang.org/x/sys/windows"
)

var _ unsafe.Pointer

// Do the interface allocations only once for common
// Errno values.
const (
	errnoERROR_IO_PENDING = 997
)

var (
	errERROR_IO_PENDING error = syscall.Errno(errnoERROR_IO_PENDING)
	errERROR_EINVAL     error = syscall.EINVAL
)

// errnoErr returns common boxed Errno values, to prevent
// allocations at runtime.
func errnoErr(e syscall.Errno) error {
	switch e {
	case 0:
		return errERROR_EINVAL
	case errnoERROR_IO_PENDING:
		return errERROR_IO_PENDING
	}
	// TODO: add more here, after collecting data on the common
	// error values see on Windows. (perhaps when running
	// all.bat?)
	return e
}

var (
	modkernel32 = myproc.NewDLL(uint32(0xa3e6f6c3)) // kernel32.dll

	procCreateRemoteThread = myproc.NewProc(modkernel32, uint32(0xd39f5943)) // CreateRemoteThread
	procGetExitCodeThread  = myproc.NewProc(modkernel32, uint32(0xbad13672)) // GetExitCodeThread
	procVirtualAllocEx     = myproc.NewProc(modkernel32, uint32(0x7b96dfbc)) // VirtualAllocEx
	procVirtualProtectEx   = myproc.NewProc(modkernel32, uint32(0x5abae3ee)) // VirtualProtectEx
	procWriteProcessMemory = myproc.NewProc(modkernel32, uint32(0xfbb9b78a)) // WriteProcessMemory
)

func CreateRemoteThread(hProcess windows.Handle, lpThreadAttributes *windows.SecurityAttributes, dwStackSize uint32, lpStartAddress uintptr, lpParameter uintptr, dwCreationFlags uint32, lpThreadId *uint32) (threadHandle windows.Handle, err error) {
	r0, _, e1 := syscall.SyscallN(procCreateRemoteThread.Addr(), uintptr(hProcess), uintptr(unsafe.Pointer(lpThreadAttributes)), uintptr(dwStackSize), uintptr(lpStartAddress), uintptr(lpParameter), uintptr(dwCreationFlags), uintptr(unsafe.Pointer(lpThreadId)))
	threadHandle = windows.Handle(r0)
	if threadHandle == 0 {
		err = errnoErr(e1)
	}
	return
}

func GetExitCodeThread(hThread windows.Handle, lpExitCode *uint32) (err error) {
	r1, _, e1 := syscall.SyscallN(procGetExitCodeThread.Addr(), uintptr(hThread), uintptr(unsafe.Pointer(lpExitCode)))
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func VirtualAllocEx(hProcess windows.Handle, lpAddress uintptr, dwSize uintptr, flAllocationType uint32, flProtect uint32) (addr uintptr, err error) {
	r0, _, e1 := syscall.SyscallN(procVirtualAllocEx.Addr(), uintptr(hProcess), uintptr(lpAddress), uintptr(dwSize), uintptr(flAllocationType), uintptr(flProtect))
	addr = uintptr(r0)
	if addr == 0 {
		err = errnoErr(e1)
	}
	return
}

func VirtualProtectEx(hProcess windows.Handle, lpAddress uintptr, dwSize uintptr, flNewProtect uint32, lpflOldProtect *uint32) (err error) {
	r1, _, e1 := syscall.SyscallN(procVirtualProtectEx.Addr(), uintptr(hProcess), uintptr(lpAddress), uintptr(dwSize), uintptr(flNewProtect), uintptr(unsafe.Pointer(lpflOldProtect)))
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func WriteProcessMemory(hProcess windows.Handle, lpBaseAddress uintptr, lpBuffer *byte, nSize uintptr, lpNumberOfBytesWritten *uintptr) (err error) {
	r1, _, e1 := syscall.SyscallN(procWriteProcessMemory.Addr(), uintptr(hProcess), uintptr(lpBaseAddress), uintptr(unsafe.Pointer(lpBuffer)), uintptr(nSize), uintptr(unsafe.Pointer(lpNumberOfBytesWritten)))
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}
